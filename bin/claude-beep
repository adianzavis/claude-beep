#!/usr/bin/expect -f

# Simple expect wrapper that replaces claude command

# Find the original claude CLI dynamically
set claude_path ""

# First try nvm locations specifically (most common for Claude Code)
set nvm_dir "$env(HOME)/.nvm"
if {[file exists $nvm_dir]} {
    foreach version_dir [glob -nocomplain "$nvm_dir/versions/node/*/lib/node_modules/@anthropic-ai/claude-code/cli.js"] {
        if {[file exists $version_dir]} {
            set claude_path $version_dir
            break
        }
    }
}

# If nvm didn't work, try to find claude in PATH and resolve symlinks
if {$claude_path == ""} {
    foreach path [split [exec printenv PATH 2>/dev/null] :] {
        set claude_candidate "$path/claude"
        if {[file exists $claude_candidate]} {
            # Skip our own wrapper
            if {$path == "/opt/homebrew/bin"} {
                continue
            }
            
            # Check if it's a symlink and resolve it
            while {[file type $claude_candidate] == "link"} {
                set claude_candidate [file readlink $claude_candidate]
                # Handle relative symlinks
                if {![string match "/*" $claude_candidate]} {
                    set claude_candidate "$path/$claude_candidate"
                }
            }
            
            # Check if it's a Node.js file (contains shebang or is large)
            if {[file exists $claude_candidate] && [file readable $claude_candidate]} {
                set claude_path $claude_candidate
                break
            }
        }
    }
}

if {$claude_path == ""} {
    puts stderr "Error: Could not find original claude CLI"
    exit 1
}

set original_claude $claude_path

# Get command line arguments
set claude_args [lrange $argv 0 end]

# Allow a beep once per prompt; re-arm after prompt disappears (debounced)
set can_beep 1
set rearm_timer ""

# Start the original claude process with node
spawn node $original_claude {*}$claude_args

# Set timeout to never timeout
set timeout -1

# Make expect transparent - pass through all input/output
interact {
    -o -re {(Do you want to (proceed\?|make [0-9]+ edits.*\?)|Opened changes in|[[:space:]]*[❯> ]?[[:space:]]*1\.[[:space:]]*Yes([[:space:]]|$))} {
        if {$can_beep} {
            catch { exec beep-disturb & }
            set can_beep 0
        }
        # Debounce: re-arm 1s after the last time we see the prompt pattern
        if {[info exists rearm_timer] && $rearm_timer ne ""} {
            after cancel $rearm_timer
        }
        set rearm_timer [after 1000 { set ::can_beep 1 }]
    }
}
