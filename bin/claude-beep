#!/usr/bin/expect -f

# Simple expect wrapper that replaces claude command

# Find the original claude CLI dynamically
set claude_path ""

# First try nvm locations specifically (most common for Claude Code)
set nvm_dir "$env(HOME)/.nvm"
if {[file exists $nvm_dir]} {
    foreach version_dir [glob -nocomplain "$nvm_dir/versions/node/*/lib/node_modules/@anthropic-ai/claude-code/cli.js"] {
        if {[file exists $version_dir]} {
            set claude_path $version_dir
            break
        }
    }
}

# If nvm didn't work, try to find claude in PATH and resolve symlinks
if {$claude_path == ""} {
    foreach path [split [exec printenv PATH 2>/dev/null] :] {
        set claude_candidate "$path/claude"
        if {[file exists $claude_candidate]} {
            # Skip our own wrapper
            if {$path == "/opt/homebrew/bin"} {
                continue
            }
            
            # Check if it's a symlink and resolve it
            while {[file type $claude_candidate] == "link"} {
                set claude_candidate [file readlink $claude_candidate]
                # Handle relative symlinks
                if {![string match "/*" $claude_candidate]} {
                    set claude_candidate "$path/$claude_candidate"
                }
            }
            
            # Check if it's a Node.js file (contains shebang or is large)
            if {[file exists $claude_candidate] && [file readable $claude_candidate]} {
                set claude_path $claude_candidate
                break
            }
        }
    }
}

if {$claude_path == ""} {
    puts stderr "Error: Could not find original claude CLI"
    exit 1
}

set original_claude $claude_path

# Get command line arguments
set claude_args [lrange $argv 0 end]

# Allow a beep once per prompt; re-arm only on user Enter
set can_beep 1

# Start the original claude process with node
spawn node $original_claude {*}$claude_args

# Set timeout to never timeout
set timeout -1

# Watch output in background without affecting display
expect_background -re {(Do you want to (proceed\?|make (this|[0-9]+) edit(s)?.*\?)|Opened changes in|[[:space:]]*[❯> ]?[[:space:]]*1\.[[:space:]]*Yes([[:space:]]|$))} {
    if {$can_beep} {
        catch { exec beep-disturb & }
        set can_beep 0
    }
}

# Transparent pass-through; re-arm strictly on Enter
interact {
    -re {\r} {
        # Re-arm on user's Enter and pass it through
        set can_beep 1
        send -- $interact_out(0,string)
    }
}
